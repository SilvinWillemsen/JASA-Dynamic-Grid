%	JASA LaTeX Sample File, Preprint Sample
%
%  Beginner Latex users should refer to their favorite online documentation
%  here is one from the TeX Users Group 
%	https://www.tug.org/twg/mactex/tutorials/ltxprimer-1.0.pdf
%
%  Useful FAQ from  https://journals.aps.org/revtex/revtex-faq
% 

%%%%%%% For Preprint
%% For manuscript, 12pt, one column style

\documentclass[dvipsnames, reprint]{JASA}
\usepackage[pdftex]{}
\graphicspath{{figures/}}
\usepackage[dvips]{epsfig,graphicx}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png, .eps}
\DeclareMathAlphabet\mathbfcal{OMS}{cmsy}{b}{n}
\usepackage{xcolor}
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother


\def\SBcomment[#1]{\tex tcolor{Red}{#1}}
\def\SWcomment[#1]{\textcolor{Bittersweet}{#1}}
\def\MDcomment[#1]{\textcolor{Blue}{#1}}
\def\SScomment[#1]{\textcolor{OliveGreen}{#1}}
\def\flip{\leftarrow}
%%%%% Preprint Options %%%%%
%% The track changes option allows you to mark changes
%% and will produce a list of changes, their line number
%% and page number at the end of the article.
 %\documentclass[preprint,trackchanges]{JASA}


%% NumberedRefs is used for numbered bibliography and citations.
%% Default is Author-Year style.
% \documentclass[preprint,NumberedRefs]{JASA}

%%%%%%% For Reprint
%% For appearance of finished article; 2 columns, 10 pt fonts

% \documentclass[reprint]{JASA}

%%%%% Reprint Options %%%%%

%% For testing to see if author has exceeded page length request, use 12pt option
% \documentclass[reprint,12pt]{JASA}


%% NumberedRefs is used for numbered bibliography and citations.
%% Default is Author-Year style.
% \documentclass[reprint,NumberedRefs]{JASA}

%% TurnOnLineNumbers
%% Make lines be numbered in reprint style:
% \documentclass[reprint,TurnOnLineNumbers]{JASA}

%% Optional algorithm package. You can comment this out and
%% include another package if you prefer another way to make
%% algorithms examples (but please check that the package is compatible with 
%%Editorial Manager; see JASA-EL-TeXGuide.pdf).


\usepackage{algpseudocode}

\begin{document}

\title[JASA/Dynamic Grids for Finite-Difference Schemes]{Dynamic Grids for Finite-Difference Schemes: Changing Parameters of Musical Instrument Simulations in Real Time}
\author{Silvin Willemsen}
\email{sil@create.aau.dk}
\author{Stefania Serafin}
\affiliation{Multisensory Experience Lab, CREATE, Aalborg University, Copenhagen, Denmark}

\author{Stefan Bilbao}
\author{Michele Ducceschi}
\affiliation{Acoustics and Audio Group, University of Edinburgh, Edinburgh, Scotland}
 
% \author{Author Five}			
% \altaffiliation{Also at: Department, University, City, State ZipCode, Country.}
% \affiliation{Department3,  University3, City, State ZipCode, Country}


\preprint{Willemsen, JASA}		%  if you want want this message to appear in upper right corner of title page

\date{\today} 

\begin{abstract}
Simulating musical instruments using physical modelling is a well-established field. Among the reasons of why one would simulate an instrument rather than sample an existing one, is that one could extend the capabilities of this instrument beyond what is physically possible, such as changing material properties or size of the instrument on the fly. Many modelling techniques exist of which finite-difference time-domain (FDTD) methods are considered the most flexible and generalisable in terms of the type of systems they can model, both linear and nonlinear. These methods do, however, lack the capability of handling smooth parameter changes while retaining optimal simulation quality, something other techniques are better suited for. This article proposes a method to dynamically alter the grids of simulations based on FDTD methods by smoothly adding and removing grid points from the system, which allows for dynamic parameter changes in physical models of musical instruments which are based on this technique. Furthermore, this technique allows the stability condition that the schemes using FDTD methods are based on, to always be satisfied with equality and thus have the highest simulation quality possible. 
\end{abstract}

%% pacs numbers not used

\maketitle

%  End of title page for Preprint option --------------------------------- %



\section{\label{sec:introduction} Introduction}
Simulation of musical instruments through physical modelling is a well established field... 
\SWcomment[Much more intro here obviously]{}
% of simulating musical instruments rather than recording them and playing them back (samples), is the flexibility of control and playability of the instrument. Imagine trying to record the entire control space of a violin, i.e., all possible combinations of bowing force, bowing velocity and fingering positions. The recording procedure would take a great amount of time and resources, let alone the amount of data storage required to store all of the high-quality audio.

% Due to the vast parameter space of many instruments, using simulations is a much more viable solution for capturing the full expressivity of an instrument than sampling.


One of the incentives of simulating the physics of musical instruments rather than sampling their real-world counterparts, is that the virtual instrument can be manipulated in physically impossible ways. Examples of this could be to change material properties, or even the shape of the instrument on the fly. An example of a real-world instrument that requires these manipulations is the trombone, where tube-length needs to be dynamic in order to play the instrument. %\SWcomment[In a companion article the authors describe a physical model of this instrument as a case study for the techniques presented here.] 

% This can be extended from musical instruments to rooms and acoustic simulation with variable shapes

Existing physical modelling techniques include mass-spring systems [REF] and digital waveguides [REF]. Modal synthesis [REF], though requiring some assumptions and simplifications for most systems, does allow for easy and smooth parameter changes -- as seen in [REF] and [REF] -- and could thus be a good candidate for implementing the aforementioned manipulations. \SWcomment[In the case of the trombone, and due to its non-homogenous geometry, there is no closed-form solution available and the modes would need to be calculated for every single slide configuration.] Finite-difference time domain (FDTD) methods on the other hand, though generally more computationally expensive than other techniques, are more flexible and generalisable and do not need as many simplifications as modal synthesis does. These methods subdivide continuous partial differential equations (PDEs) that describe the physics of the system at hand into a grid of discrete points in space and time. 
%
% Below, a brief introduction about grids and their relationship to stability is explained.
%
% \subsection{Grids and stability}
The distance between two discrete points in space (the grid spacing) and the time step between two discrete moments in time are closely connected through a \textit{stability condition}. This condition dictates the maximum number of points allowed to describe system before it gets unstable and the simulation ``explodes''. The closer the grid spacing is to the stability condition, the higher the quality of the simulation. If the condition is satisfied with equality, the quality of the simulation is at a maximum. 
Furthermore, the stability condition depends on the parameters of the model, such as material properties or size of the system, i.e., parameters that could be changed on the fly.

This article proposes a method to smoothly add and subtract points from a system in real time so that the stability condition is always satisfied with equality. This allows for a simulation where the parameters can be changed dynamically without running into either stability or quality issues. 

This article is structured as follows: 
\textit{NOTES:}
\begin{itemize}
% \item Section 2: Background on PDE $\rightarrow$ FDTD $\rightarrow$ stability conditions 
\item Section 2: Continuous systems
\item Section 3: Numerical methods
\item Section 4: Dynamic grid
\item Section 5: Results
\item Section 6: Discussion
\item Section 7: Conclusions and Future work
\end{itemize}
\section{Continuous Systems}\label{sec:continuous}
%
%going from a partial differential equation (PDE) to an update equation that can be implemented.
%
%using the famous 1D wave equation.
%
The physics of dynamic systems is commonly described using partial differential equations (PDEs) operating in continuous time. To aid the illustration of the proposed method, the 1D wave equation will be used. \SWcomment[This does not mean that the method is limited to this, and could be extended to other (linear) systems, possibly even higher dimensional ones.]

Consider a 1-dimensional system with length $L$ (in m) described by state variable $u = u(x, t)$ defined over spatial domain $x \in [0, L]$ (in m) and time $t \geq 0$ (in s). The partial differential equation (PDE) of the 1D wave equation is then described as
\begin{equation}\label{eq:1dwave}
    \frac{\partial^2 u}{\partial t^2}= c^2\frac{\partial^2 u}{\partial x^2}\ ,
\end{equation}
parameterised by wave speed $c$ (in m/s). As $x$ in Eq. \eqref{eq:1dwave} is only defined over a finite region in space, boundary conditions need to be provided. Two possible conditions are
\begin{subequations}\label{eq:continuousBoundaries}
    \begin{align}
        u(0, t) = u(L, t) &= 0\quad \text{(Dirichlet)},\label{eq:contDirichlet}\\
        \frac{\partial}{\partial x} u(0, t) = \frac{\partial}{\partial x} u(L, t) &= 0\quad \text{(Neumann)},\label{eq:contNeumann}
    \end{align}
\end{subequations}
which describe a `fixed' and `free' boundary respectively.

\subsection{Dynamic parameters}\label{sec:dynamicParamsCont}
In the case of the 1D wave equation, only the wave speed $c$ and length $L$ can be altered. If Dirichlet-type boundary conditions -- as in Eq. \eqref{eq:contDirichlet} -- are used, the fundamental frequency $f_0$ of the 1D wave equation can be calculated according to
\begin{equation}\label{eq:fundamentalFreqCont}
    f_0 = \frac{c}{2L}\,.
\end{equation}
From Eq. \eqref{eq:fundamentalFreqCont}, one can easily conclude that, in terms of fundamental frequency halving the length of Eq. \eqref{eq:1dwave} is identical to doubling the wave speed and vice versa. Looking at system \eqref{eq:1dwave} in isolation, $f_0$ is the only behaviour of the system that can be changed. One can thus leave $L$ fixed %($L = 1$ for simplicity) 
and make $c$ dynamic (or time-varying), i.e., $c = c(t)$, which will prove easier to work with in the following section.

\section{Numerical methods}\label{sec:FDTD}
This section will give a brief introduction of physical modelling using FDTD methods, including details on stability and quality of the simulations based on these methods.

\subsection{Discretisation}
Using FDTD methods, the continuous 1D wave equation in Eq. \eqref{eq:1dwave} can be discretised into points in space and time. The spatial variable can be discretised using $x_l = lh$ (read: $x$ at location $l$) with integer $l \in [0, \hdots, N]$, grid spacing (distance between two consecutive grid points) $h$ (in m) and total number of points $N + 1$ (including the boundaries) where the total number of intervals between the grid points is described as
\begin{equation}\label{eq:numberOfIntervals}
    N = \lfloor L/h\rfloor,
\end{equation}
with $\lfloor \cdot \rfloor$ denoting the flooring operation. The temporal variable can be discretised using $t_n = nk$ with positive integer $n$, time step $k = 1/f_\text{s}$ (in s) and sample rate $f_\text{s}$ (in Hz). The state variable $u$ can then be approximated using $u(x,t) \approx u_l^n$, where grid function $u_l^n$ is ``the displacement of $u$ at spatial index $l$ and time index $n$". The total state at time index $n$ is then denoted as vector $\mathbf{u}^n$ with size $N+1$.

The following operators can then be applied to $u_l^n$ to get the following approximations to the derivatives in Eq. \eqref{eq:1dwave}
\begin{subequations}\label{eq:operators}
    \begin{align}
         \delta_{tt}u_l^n &= \frac{1}{k^2}\left(u_l^{n+1}-2u_l^n + u_l^{n-1}\right)\;\;\approx\quad\frac{\partial^2u}{\partial t^2}\label{eq:secondOrderTime}\ ,\\
         \delta_{xx}u_l^n &= \frac{1}{h^2}\left(u_{l+1}^n-2u_l^n + u_{l-1}^n\right)\quad\approx\quad \frac{\partial^2u}{\partial x^2}\ .\label{eq:secondOrderSpace}
    \end{align}
\end{subequations}
Substituting these definitions into Eq. \eqref{eq:1dwave} yields the following finite-difference scheme (FDS)
\begin{equation}\label{eq:FDS}
    \delta_{tt}u_l^n = c^2 \delta_{xx}u_l^n.
\end{equation}
Expanding the operators as in %the Eqs. in
\eqref{eq:operators} and solving for $u_l^{n+1}$ (which is the only unknown) yields the following update equation
\begin{equation}\label{eq:updateEq}
    u_l^{n+1} = 2u_l^n-u_l^{n-1} + \lambda^2 \left(u_{l+1}^n-2u_l^n + u_{l-1}^n\right),
\end{equation}
saying that $u$ at the next time index ($n+1$) can be calculated using only values of $u$ at the current ($n$) and previous time indices ($n-1$). \SWcomment[This update can be implemented in software, such as {\tt MATLAB} or {\tt C++}.] Here,
\begin{equation}\label{eq:lambdaDef}
    \lambda = \frac{ck}{h}
\end{equation}
is referred to as the Courant number and determines whether the system is stable, as well as the quality and behaviour of the simulation. This will be described in detail in Sections \ref{sec:stability} and \ref{sec:quality}.

In the FDS described in Eq. \eqref{eq:FDS}, the boundary locations are at $l = 0$ and $l = N$. Substituting these locations into Eq. \eqref{eq:updateEq} seemingly shows that grid points outside of the defined domain are needed, namely $u_{-1}^n$ and $u_{N+1}^n$. These can be referred to as \textit{virtual grid points} and can be accounted for %/defined
by using the boundary conditions in Eq. \eqref{eq:continuousBoundaries}. Discretising these yields
\begin{subequations}
    \begin{align}
        u_0^n = u_N^n &= 0 \quad\text{(Dirichlet)}\label{eq:discreteDirichlet}\\
        \delta_{x\cdot} u_0^n = \delta_{x\cdot} u_N^n &= 0 \quad \text{(Neumann)}\label{eq:discreteNeumann}
    \end{align}
\end{subequations}
where 
\begin{equation}
    \frac{\partial u}{\partial x} \approx \delta_{x\cdot}u_l^n = \frac{1}{2h}\left(u_{l+1}^n - u_{l-1}^n\right)
\end{equation}
is a second-order accurate approximation of the first-order spatial derivative. The Dirichlet condition in \eqref{eq:discreteDirichlet} says that the states at the boundary locations are always 0. In practice, this means that these grid points do not need to be updated and the spatial range of calculation for Eq. \eqref{eq:updateEq} then becomes $l = [1, \hdots, N-1]$. If the Neumann condition is used, the boundary points do need to be updated as these are not necessarily $0$; rather, their `slope' is $0$. Eq. \eqref{eq:discreteNeumann} can then be expanded to yield defnitions for these virtual grid points
\begin{equation}\label{eq:neumannSolution}
    u_{-1}^n = u_1^n \quad \text{and} \quad u_{N+1}^n = u_{N-1}^n\,.
\end{equation}

Now that the full system is described the output sound can be retrieved by following the state $u_l^n$ in Eq. \eqref{eq:updateEq} at $0 < l < N$ (when using fixed boundary conditions \SWcomment[, unless silence is your thing]) and listening to that at the given sample rate $f_\text{s}$.

\subsection{Stability}\label{sec:stability}
Discretising continuous equations using numerical methods places limits on the parameters describing it. A wrong choice of parameters could render the system unstable and make it ``explode". In the case of the update in Eq. \eqref{eq:updateEq} it can be shown -- using Von Neumann stability analysis [REF] -- that the system is stable if
\begin{equation}\label{eq:CFL}
    \lambda \leq 1,
\end{equation}
which is referred to as the Courant-Friedrichs-Lewy (CFL) stability condition. The closer $\lambda$ is to this condition, the higher the quality of the simulation (see Section \ref{sec:quality}) and if $\lambda = 1$, Eq. \eqref{eq:updateEq} provides an exact solution to Eq. \eqref{eq:1dwave} %(this is true for the 1D wave equation)
[REF] (see Figures \ref{fig:lambda1} and \ref{fig:lambda0.9}). If $\lambda > 1$ the system will become unstable (see Figure \ref{fig:lambda1.001}).
\begin{figure*}
\figline{\fig{ulnLambda1}{.25\textwidth}{(A)}\label{fig:lambda1}
\fig{ulnLambda09}{.25\textwidth}{(B)}\label{fig:lambda0.9}
\fig{ulnLambda1001}{.25\textwidth}{(C)}\label{fig:lambda1.001}
\narrowcaption{.25\textwidth}{State $u_l^n$ with $N = 50$ and $f_\text{s} = 44100$ visualised. (A) If $\lambda = 1$, the solution is exact. (B) If $\lambda < 1$ dispersive behaviour shows. (C) If $\lambda > 1$ the CFL condition in Eq. \eqref{eq:CFL} is not satisfied and the system ``explodes".
\label{fig:dispersion}}}
\end{figure*}
% discrete boundaries here?
Recalling \eqref{eq:lambdaDef} can rewrite Eq. \eqref{eq:CFL} in terms of grid spacing $h$ to get
\begin{equation}\label{eq:stabilityCond}
    h \geq ck.
\end{equation}
This shows that the CFL condition in \eqref{eq:CFL} puts a lower bound on the grid spacing, calculated from the sample rate and wave speed. Usually, the following steps are taken to calculate $\lambda$
\begin{equation}\label{eq:orderOfCalcGrid}
    h := ck,\ \ N := \left\lfloor\frac{L}{h}\right\rfloor, \ \ h := \frac{L}{N}, \ \ \lambda := \frac{ck}{h}.
\end{equation}
In other words, condition \eqref{eq:stabilityCond} is first satisfied with equality and used to calculate integer $N$ according to Eq. \eqref{eq:numberOfIntervals}. Thereafter, $h$ is recalculated based on $N$ and used to calculate $\lambda$. The calculation of $\lambda$ in Eq. \eqref{eq:orderOfCalcGrid} can be compactly rewritten as
\begin{equation}\label{eq:compactLambda}
    \lambda = \frac{ck}{L}\cdot\left\lfloor\frac{L}{ck}\right\rfloor.
\end{equation}
The flooring operation causes the CFL condition in \eqref{eq:CFL} to not always be satisfied with equality and results in a reduced simulation quality described in the following section.

\subsection{Simulation Quality}\label{sec:quality}
As mentioned above, the Courant number $\lambda$ decides the quality of the simulation. Choosing $\lambda < 1$ will decrease this quality in two ways. Firstly, it will decrease the maximum frequency that the simulation is able to produce, i.e., it will decrease the bandwidth of the output sound of the system. See Figure \ref{fig:bandWidths}.
%
\begin{figure*}
\figline{\fig{bandwidthLambda1}{.25\textwidth}{(A)}
\fig{bandwidthLambda09}{.25\textwidth}{(B)}
\fig{bandwidthLambda05}{.25\textwidth}{(C)}
\narrowcaption{.25\textwidth}{Bandwidths of the simulation output %at $l = 16$ 
with $f_\text{s} = 44100$ Hz and 
%$N = 50$ excited with a raised cosine with a width of 5 at center-location $N = 25$. The Courant number is set to 
(A) $\lambda = 1$, (B) $\lambda = 0.9$ and (C) $\lambda = 0.5$. 
\label{fig:bandWidths}}}
\end{figure*}
%
By analysing the scheme in Eq. \eqref{eq:updateEq}, it can be shown that the maximum frequency produced by the system can be calculated using \cite[Chap. 6]{bilbao2009}
\begin{equation}\label{eq:fmax}
    f_\text{max} = \frac{f_\text{s}}{\pi} \sin^{-1}(\lambda),
\end{equation}
shown in Figure \ref{fig:bandWidthFormula}.
%
Note that only a small deviation of $\lambda$ from condition \eqref{eq:CFL} already has a profound effect on the bandwidth of the output.

\begin{figure}
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=0.8\reprintcolumnwidth]{bandwidthPlot}
\caption{\label{fig:bandWidthFormula}{The effect of the Courant number $\lambda$ on the output bandwidth. \SWcomment[This figure should probably be much more compact, if not removed altogether.]}}
\end{figure} 

Secondly, choosing $\lambda < 1$ causes numerical dispersion. See Figures \ref{fig:lambda0.9} and \ref{fig:bandWidths}. Harmonic partials get closer together at higher frequencies (i.e. get more inharmonic) as $\lambda$ decreases, which is generally undesirable.

Apart from the recalculation of $\lambda$ due to the flooring operation in Eq. \eqref{eq:orderOfCalcGrid}, a reason that one would choose $\lambda < 1$ could be to decrease the total number of grid points used in the simulation by increasing $h$. This makes the simulation less computationally expensive, while keeping a desired wave speed $c$ and time step $k$. For 1-dimensional systems such as the 1D wave equation, this is rarely necessary.

\section{Dynamic Parameters}\label{sec:dynamicParams}
This section describes how parameters could be made dynamic using the state of the art and what this means for the simulation quality detailed in Section \ref{sec:quality}. %To clarify, for a parameter to be dynamic refers to its ability to vary over time while the simulation is running.  
To clarify, a \textit{dynamic} parameter refers to one that is time-varying while the simulation is running. 

% For the 1D wave equation used in Section \ref{sec:FDTD}, a property that could be interesting to make time-varying is the fundamental frequency $f_0$. If Dirichlet-type boundary conditions are used, as defined in Eqs. \eqref{eq:contDirichlet} and \eqref{eq:discreteDirichlet}, $f_0$ can be calculated according to
% \begin{equation}\label{eq:fundamentalFreq}
%     f_0 = \frac{c}{2L}\,.
% \end{equation}
% If $\lambda = 1$ in \eqref{eq:CFL} and thus condition \eqref{eq:stabilityCond} is satisfied with equality, $L/h$ in Eq. \eqref{eq:numberOfIntervals} is an integer and the flooring operation can be ignored. Substituting \eqref{eq:numberOfIntervals} into \eqref{eq:fundamentalFreq} yields
% \begin{equation}
%     f_0 = \frac{1}{2Nk}\ ,
% \end{equation}
% which shows that if $\lambda = 1$, $N$ solely decides the fundamental frequency of the simulation.

Usually when simulating instruments, the parameters that describe the system are fixed for the entire simulation. For the 1D wave equation used in Section \ref{sec:continuous}, these are the wave speed $c$ and time step $k$ (calculated from the sample rate $f_\text{s}$) from which the grid spacing $h$ and Courant number $\lambda$ are calculated. On top of this, the length $L$ can be changed, but as elaborated on in Section \ref{sec:dynamicParamsCont}, this can be directly translated to a change in $c$ through the fundamental frequency $f_0$. As $f_\text{s}$ is rarely changed \SWcomment[due to all sorts of issues], the sole parameter that could be interesting to make time-varying is $c$. 
% Modal synthesis is based on the addition of many sinusoids and is thus defined over the entire space. One can simply change the frequency of these sinusoids and 

% \begin{equation}\label{eq:modalSum}
%     u(x,t) = \sum_{m=1}^M C_m\sin(\omega_mt+\phi_m)\sin\Big(\frac{m\pi x}{L}\Big),
% \end{equation}
%
% The amount of modes that can be included also depends on a stability condition, but it is much easier to work with. One simply excludes modes that do not satisfy this condition. 
%
% Using FDTD methods, one uses a discrete set number of points making it hard to transition from one setting to the next.
As $c$ changes, several things need to be taken into account. First of all, a change in $c$ causes a change in $\lambda$ according to Eq. \eqref{eq:compactLambda} affecting the simulation quality and bandwidth. Secondly, and more importantly, a change in $c$ could result in a change in $N$ through Eq. \eqref{eq:numberOfIntervals}. As $N$ directly relates to the number of grid points, this raises questions as to \textit{where} and especially \textit{how} one would add and remove points to the grid according to the now-dynamic wave speed.

A solution to the latter is to set and fix $N$ and tune $c$ away from the stability condition by decreasing it, such as done in [REF]. This would avoid problems with stability, as decreasing $c$ would continue to satisfy condition \eqref{eq:CFL}, but the simulation would end up with lower quality, exhibiting dispersive and bandlimiting effects as discussed in Section \ref{sec:quality}. In essence, decreasing the value of $c$ immediately translates to decreasing the value of $\lambda$ as $h$ and $k$ are left unchanged. On top of this, $c$ is limited by Eq. \eqref{eq:CFL} and increasing it beyond a certain value would render the system unstable.

The only way to circumvent the aforementioned undesirable effects such as dispersion and bandlimiting, is to somehow allow $N$ to be fractional \SWcomment[(i.e., non-integer)]. This will remove the flooring operation in Eq. \eqref{eq:numberOfIntervals} and Eq. \eqref{eq:compactLambda}, and will consequently satisfy the CFL condition in \eqref{eq:CFL} with equality at all times. Eq. \eqref{eq:fundamentalFreqCont} can then be rewritten in terms of $N$ by substituting Eq. \eqref{eq:numberOfIntervals} into Eq. \eqref{eq:fundamentalFreqCont} (using Eq. \eqref{eq:stabilityCond} satisfied with equality) yielding
\begin{equation}\label{eq:fundamentalFreq}
    f_0 = \frac{1}{2Nk}\ .
\end{equation}
This shows that if $\lambda = 1$, $N$, which is now not necessarily an integer, solely decides the fundamental frequency of the simulation. 

As this still leaves the question of where and how to add and remove points to and from the grid
%. To implement a physical model with dynamic parameters and an optimal simulation quality at all times,
a method needs to be devised to dynamically and smoothly change the number of grid points. This paper proposes a method to do this and is described in the following section. %The following section describes the requirements for such a method to successfully do this.

% Section \ref{sec:quality} shows several arguments for why these parameters should be fixed. The stability of the simulation relies on the parameters of the scheme and needs to be satisfied as close to the condition  When the stability condition is calculated,

% In this case we could initialise the system to have a wave speed of $c = 300$ m/s and a sample rate of $f_\text{s} = 44100$ Hz yielding $N = 147$ and $lambda = 1$ (satisfying condition \eqref{eq:CFL} with equality.

% Essentially $c$ is made time-varying / dynamic / changed on the fly $c^n$
% \subsection{Connection between $c$ and $L$ \SWcomment[(might be better as an appendix)]}\label{sec:f0}
% If Dirichlet-type boundary conditions are used, as defined in Eqs. \eqref{eq:contDirichlet} and \eqref{eq:discreteDirichlet}, the fundamental frequency $f_0$ of the 1D wave equation can be calculated according to
% \begin{equation}
%     f_0 = \frac{c}{2L}\,,
% \end{equation}
% from which one can see that, in terms of fundamental frequency a halving the length is identical to doubling the wave speed. 
% If $\lambda = 1$ in \eqref{eq:CFL} and thus condition \eqref{eq:stabilityCond} is satisfied with equality, $L/h$ in Eq. \eqref{eq:numberOfIntervals} is an integer and the flooring operation can be ignored. Substituting \eqref{eq:numberOfIntervals} into \eqref{eq:fundamentalFreq} yields
% \begin{equation}
%     f_0 = \frac{1}{2Nk}\ ,
% \end{equation}
% which shows that if $\lambda = 1$, $N$ solely decides the fundamental frequency of the simulation.

\section{The Dynamic Grid}
By now, it is hopefully clear to the reader why dynamic parameters would make an interesting case in the field of physical modelling, and why dynamic grids would be a good solution to undesirable behaviour such as a decrease in bandwidth and increase in numerical dispersion discussed in Section \ref{sec:quality}. %This section will describe the problems that arise when adding and removing grid points. Afterwards, some iterations done over the course of this project and their drawbacks will be shown, leading up to the final implementation of the dynamic grid. 

% The first questions that need to be answered are ``where to add points?" and ``how to add points?" The problems when doing this range from artifacts or auditory `clicks' in the output sound to ``exploding" systems due to artificial injection of energy. 
In this section, the requirements of a method that dynamically changes the grid will be explained. Then, the iterations done over the course of this project will briefly be described, the details of each can be found in Appendix \ref{app:A}. Finally, the proposed method will be described in detail and summarised in the end.

\subsection{Method requirements}\label{sec:methodReq}
Ideally, a method that dynamically changes the grid size of finite-difference schemes should
\begin{enumerate}
    \item generate an output with a fundamental frequency $f_0$ %described by Eq. \eqref{eq:fundamentalFreq} 
    which is (linearly) proportional to $c$ ($f_0 \propto c$),
    \item allow for a fractional $N$ to smoothly transition 
    %between different $f_0$s,
    %\item smoothly transition 
    between different numbers of grid points so that no artefacts (auditory clicks) are present in the output sound,
    \item generate an output containing harmonic partials -- or modes -- which are integer multiples of the fundamental ($f_p = f_0 p$ with integer $p$),
    \item generate an output with $\lfloor N\rfloor-1$ modes corresponding to the number of moving points of the system ($p = [1, \hdots, \lfloor N\rfloor-1]$),\\
    \item work in real time.
\end{enumerate}
%
% The total amount of modes is expected to be equal to $N-1$ corresponding to the total number of moving grid points (points excluding the boundary).
%As the variables $c$, $h$, $\lambda$ and $N$ are now time-varying, a superscript $n$ or $n-1$ is added when necessary. If omitted, a time index $n$ is assumed.

\subsection{Iterations}\label{sec:iterations}
One method that could be used to go from one grid configuration to the next is full-grid interpolation as described in \cite[Chap. 5]{bilbao2009}. However, this method essentially has a lowpassing effect on the system state and can cause `clicks' in the output sound due to the interpolation. A (much) higher sample rate could be used to avoid these issues, but this would render this method impossible to work in real time.

Another method is to add and remove points at the boundary using an interpolated boundary condition, the possibility of which has been briefly mentioned in \cite[p. 145]{bilbao2009}. If the boundary is fixed through Eq. \eqref{eq:contDirichlet}, the state at this location will always be $0$ and potentially allows for smooth entry and exit of grid points. This method can be seen analogous to tuning a guitar string where string-material enters and leaves the playable part of the string at the nut, the boundary. The interpolated nature of the boundary does allow for a ``fractional" $N$ as described in Section \ref{sec:dynamicParams} and has a fundamental frequency calculated using \eqref{eq:fundamentalFreq}. %removing the flooring operation in Eq. \eqref{eq:compactLambda} and always satisfying the CFL condition with equality. \SWcomment[This has the added feature that $L/h$ in Eq. \eqref{eq:numberOfIntervals} is an integer and the flooring operation can be ignored. Substituting Eq. \eqref{eq:numberOfIntervals} into Eq. \eqref{eq:fundamentalFreqCont} (using Eq. \eqref{eq:stabilityCond} satisfied with equality) yields
%\begin{equation}%\label{eq:fundamentalFreq}
%     f_0 = \frac{1}{2Nk}\ ,
% \end{equation}
% which shows that if $\lambda = 1$, $N$, which is now not necessarily an integer, solely decides the fundamental frequency of the simulation.] 
Although informal testing shows that adding points to the grid can happen smoothly, removing points smoothly is more challenging. This is due to the fact that the grid point at the boundary will be moving right before it is removed and its displacement needs to (somehow) smoothly be reduced to 0 to satisfy the fixed boundary condition in Eq. \eqref{eq:contDirichlet}. %\SWcomment[$\leftarrow$ if simply supported condition is mentioned here] Even though the $\delta_{xx}u$ part of this condition can be easily satisfied, the $u=0$ part can not.

\subsection{Proposed Method}\label{sec:proposedMethod}
This section introduces the proposed method of dynamically and smoothly changing the grid to account for dynamic parameter changes. To avoid the issues of adding and removing points at the boundary due to boundary conditions, they can be added or removed along the grid instead. For the sake of simplicity in explanation, the location is chosen to be the center of the system. \SWcomment[At the end of this section, the location exhibiting the best behaviour will be shown.] In the following, the location of a grid point (in m from the left boundary) $i$ (such as $i = u_0$) is denoted by $x_i$. 

\subsubsection{System Setup}\label{sec:systSetup}
Consider a grid function, $u_l^n$ with integer $M_u = \lceil 0.5L/ck\rceil $ (or simply $M$ below for brevity) \SWcomment[($\lceil \cdot \rceil$ denoting the ceiling operation)] and $w_l^n$ with integer $M_w = \lfloor 0.5L/ck\rfloor$, i.e., half the number of points allowed by the stability condition, plus one for overlap (see Figure \ref{fig:twoFreeStrings}). The following boundary conditions are then imposed:
\begin{subequations}\label{eq:halfStringBoundaryCond}
    \begin{align}
        u_0^n = w_{M_w}^n &= 0,\quad \text{(Dirichlet)}\label{eq:halfStringBoundaryCondDirichlet}\\
        \delta_{x\cdot}u_M^n = \delta_{x\cdot}w_0^n &= 0.\, \quad\text{(Neumann)}, \label{eq:halfStringBoundaryCondNeumann}
    \end{align}
\end{subequations}
i.e., the outer boundaries are fixed and the inner boundaries are free.
% \begin{figure}[h]
% \centerline{\includegraphics[width=\columnwidth]{twoFreeStrings.eps} }
% \caption{\label{fig:twoFreeStrings}{Two (1D wave) systems connected at one of their boundaries.}}
% \end{figure}
%
\begin{figure}[ht]
% \baselineskip=12pt
\figcolumn{
\fig{twoFreeStrings}{\reprintcolumnwidth}{(A)}\label{fig:twoFreeStrings}
\fig{twoFreeStringGridMove}{\reprintcolumnwidth}{(B)}\label{fig:twoFreeStringsGridMove}
\fig{twoFreeStringGridMoveZoomed2}{\reprintcolumnwidth}{(C)}\label{fig:twoFreeStringsGridZoomed}
}
\caption{Illustration of the proposed method. (A) Locations of the states of two (1D wave) systems connected at the inner boundary ($N = 30$, $x_{u_M} = x_{w_0}$). (B) When $c$ -- and consequently $h$ -- are decreased and the positions of the grid points change ($N = 30.5$, $x_{u_M} \neq x_{w_0}$). (C) Figure \ref{fig:twoFreeStringsGridMove} zoomed-in around $x_{u_M}$ and $x_{w_0}$. The states at the inner boundaries $u_M$ and $w_0$ are shown together with virtual grid points $u_{M+1}$ and $w_{-1}$. In all figures, the x-axis shows the location (in m) of the respective grid points (fx. $x_{u_l}$), but the $x$ is omitted for brevity.}
\end{figure}
%
The systems can then be connected at the inner boundaries ($u_M$ and $w_0$) using a rigid connection, i.e. \SWcomment[(only valid if $x_{u_M} = x_{w_0}$)],
\begin{equation}\label{eq:rigid}
    u_M^n = w_0^n,\quad \forall n.
\end{equation}
Essentially, the complete system is divided into two separate systems connected at the inner boundary. 

With these boundary conditions imposed, the following, state (column) vectors can be defined:
\begin{equation}
    \begin{aligned}\label{eq:separateStateVectors}
     \mathbf{u}^n &= [u_1^n, \hdots, u_M^n]^T, \\
     \mathbf{w}^n &= [w_0^n, \hdots, w_{M_w-1}^n]^T 
    \end{aligned}
\end{equation}
(with $T$ denoting the transpose operation) and have $M$ and $M_{w}$ points respectively (excluding the outer boundaries). The vector concatenating these is then defined as 
\begin{equation}\label{eq:fullState}
    \mathbfcal{U}^n = \begin{bmatrix}
        \mathbf{u}^n \\
        \mathbf{w}^n
    \end{bmatrix}
\end{equation}The system will now be
\begin{equation}
    \begin{cases}\label{eq:systemHalfStrings}
        \delta_{tt}u_l^n = c^2\delta_{xx}u_l^n + J(x_{u_M})F\\
        \delta_{tt}w_l^n = c^2\delta_{xx}w_l^n - J(x_{w_0})F
    \end{cases}
\end{equation}
with spreading operator
\begin{equation}
    J(x_i) =
    \begin{cases}
        \frac{1}{h}, & l = l_i\\
        0,& \text{otherwise}
    \end{cases}
\end{equation}
and the effect of the connection \SWcomment[(``connection force", but not really as it isn't in N)] $F$ (in m$^2$/s$^2$).
%
Expanding the spatial operators in system \eqref{eq:systemHalfStrings} at inner boundaries $u_M^n$ and $w_0^n$, recalling the conditions in  \eqref{eq:halfStringBoundaryCond} and the definition for the virtual grid points needed for the Neumann condition in Eq. \eqref{eq:neumannSolution} yields
\begin{equation}\label{eq:expandedSystem}
    \begin{cases}
        \delta_{tt}u_M^n = \frac{c^2}{h^2}(2u_{M-1}^n-2u_M^n) + \frac{1}{h}F\\
        \delta_{tt}w_0^n = \frac{c^2}{h^2}(2w_1^n-2w_0^n) - \frac{1}{h}F.
    \end{cases}
\end{equation}
Because of Eq. \eqref{eq:rigid}, it is also true that $\delta_{tt}u_M^n = \delta_{tt}w_0^n$, and $F$ can be calculated by setting the \SWcomment[right side of the] equations in \eqref{eq:systemHalfStrings} equal to each other:
\begin{align}
     \frac{c^2}{h^2}(2u_{M-1}^n-2u_M^n) + \frac{1}{h} F&= 
     \frac{c^2}{h^2}(2w_1^n-2w_0^n) - \frac{1}{h} F\nonumber\\
    % \frac{2}{h}F &= \frac{c^2}{h^2}(2w_1^n - 2u_{M-1}^n)\nonumber\\
    F &= h \frac{c^2}{h^2}(w_1^n - u_{M-1}^n)
\end{align}
Substituting this into system \eqref{eq:expandedSystem} after expansion of the second-time derivative yields
\begin{equation}\label{eq:resultOneConnectedPoint}
    \!\begin{cases}
    u^{n+1}_M = 2u_M^n - u_M^{n-1} + \lambda^2(u_{M-1}^n-2u_M^n+w_1^n)\\
    w^{n+1}_0 = 2w_0^n - w_0^{n-1} + \lambda^2(u_{M-1}^n-2w_0^n+w_1^n)
    \end{cases}
\end{equation}
which, (again, recalling Eq. \eqref{eq:rigid}) are indeed equivalent expressions for the connected point. Here, $w_1^n$ in the first expression acts as virtual grid point $u_{M+1}^n$ and $u_{M-1}^n$ as virtual grid point $w_{-1}^n$, essentially connecting the two systems using the state of one in the update of the other.

\subsubsection{Changing the Grid}
Section \ref{sec:systSetup} describes the case in which the stability condition is satisfied with equality, i.e, when $1/ck$ is an integer and $x_{u_M} = x_{w_0}$ \SWcomment[(read as: the locations of grid points $u_M$ and $w_0$ are identical)]. The locations of the outer boundaries $x_{u_0}$ and $x_{w_{M_w}}$ are fixed, i.e.
\begin{equation}
    x_{u_0}^n = x_{u_0}^0 \quad \text{and}\quad x_{w_{M_w}}^n = x_{w_{M_w}}^0 \quad \forall n.
\end{equation}
If the wave speed $c$ is then decreased, and consequently the grid spacing $h$ according to $h=ck$, all other points move towards their respective outer boundary (see Figure \ref{fig:twoFreeStringsGridMove}). Calculating $h$ this way allows this method to always satisfy the CFL condition in Eq. \eqref{eq:CFL} with equality, as is the case with the previous iteration described in \ref{sec:iterations}.

% \begin{figure}[h]
% \centerline{\includegraphics[width=\columnwidth]{twoFreeStringGridMove} }
% \caption{\label{fig:twoFreeStringsGridMove}{When the grid changes ($N = 30.5$). The x-axis shows the location (in m) of the respective grid points (fx. $x_{u_l^n}$), but the $x$ is omitted for clarity.}}
% \end{figure}
%
As mentioned above, the state of $\mathbf{w}^n$ (from \eqref{eq:separateStateVectors}) can be used to calculate the virtual grid point needed at the right boundary of $\mathbf{u}^n$ and vice versa. If $x^n_{u_{M+1}} \neq x^n_{w_1}$ (and thus $x^n_{w_{-1}} \neq x^n_{u_{M-1}}$) \SWcomment[$\leftarrow$ I think this is clearer than simply saying $x_{w_0} \neq x_{u_M}$ as these are used in the Eqs. in \eqref{eq:interpolationGeneral} below] an interpolator $I(x_i)$ at location $x_i$ (in m) can be used to calculate the value of this virtual grid point
\begin{subequations}\label{eq:interpolationGeneral}
    \begin{align}
        u_{M+1}^n &= I^\flip(x^n_{u_{M+1}})\mathbf{w}^n% = (1-\alpha)w_1^n + \alpha w_0^n
        \\
        w_{-1}^n &= I(x^n_{w_{-1}})\mathbf{u}^n,% = (1-\alpha)u_{M-1}^n + \alpha u_M^n
    \end{align}
\end{subequations}
where $I^\flip$ is a flipped version of $I$. 
% where
% \begin{equation}
%     \alpha = \frac{x_{w_0} - x_{u_M}}{h},
% \end{equation}
% and grid-point locations $x_{u_{M+1}}$ and $w_{-1}$. Note that when $h$ changes the connected points start to move away from each other.
%
If linear interpolator $I_1$ is used, the Eqs. in \eqref{eq:interpolationGeneral} can easily be calculated from known values according to
\begin{subequations}
    \begin{align}
        u_{M+1}^n &= I_1^\flip(x^n_{u_{M+1}})\mathbf{w}^n = \alpha w_0^n
        + (1-\alpha)w_1^n\\
        w_{-1}^n &= I_1(x^n_{w_{-1}})\mathbf{u}^n = (1-\alpha)u_{M-1}^n + \alpha u_M^n
    \end{align}
\end{subequations}
where
\begin{equation}\label{eq:alphaDef}
    \alpha = \alpha^n = \frac{x^n_{w_0} - x^n_{u_M}}{h}\,.
\end{equation}
Also see Figure \ref{fig:twoFreeStringsGridZoomed}.
% \begin{figure}[h]
% \centerline{\includegraphics[width=\columnwidth]{twoFreeStringGridMoveZoomed} }
% \caption{\label{fig:twoFreeStringsGridZoomed}{When the grid changes (zoomed). The states at the inner boundaries $u_M$ and $w_0$ are shown together with virtual grid points $u_{M+1}$ and $w_{-1}$.}}
% \end{figure}
%
Using $I_1$, analysis of the output shows that the expected fundamental frequency $f_0$ is slightly higher when interpolation needs to happen than the one expected when using Eq. \eqref{eq:fundamentalFreq}. Furthermore, modes higher than $f_\text{s} / 4$ would follow an odd pattern up when decreasing the wavespeed, opposite of what is expected.

One could extend the range of interpolation by one point to each side, and using a cubic interpolator. Though this would require $w_{-1}$ to calculate $u_{M+1}$ and vice versa, it is possible to solve this by treating the interpolation equations as a system of linear equations. Analysis of this method, though yielding a correct $f_0$ at all times, shows similar behaviour to the linear interpolation, with odd behaviour regarding to modes higher than $f_\text{s}/2$.

Much better behaviour is observed when points of both $u$ and $w$ are used, i.e., using $u_M$ to calculate $u_{M+1}$ and $w_0$ for $w_{-1}$. Now, the grid points used in the interpolation are not equidistant and a custom interpolator needs to be created. The lowest order interpolator that can be used here is the quadratic Lagrangian interpolator $I_2$ and when applied to Eq. \eqref{eq:fullState} yields
\begin{subequations}\label{eq:connectionInterpol}
\begin{align}
    &\begin{aligned}\label{eq:calcUMP1}
        u_{M+1}^n &= I_2^\flip(x^n_{u_{M+1}})\mathbfcal{U}^n\\
        &= \frac{\alpha - 1}{\alpha + 1}u_{M}^n + w_0^n - \frac{\alpha - 1}{\alpha + 1}w_1^n
    \end{aligned}\\
    &\ \ \begin{aligned}\label{eq:calcWM1}
        w_{-1}^n &= I_2(x^n_{w_{-1}})\mathbfcal{U}^n \\
        &=-\frac{\alpha - 1}{\alpha + 1}u_{M-1}^n + u_{M}^n+ \frac{\alpha - 1}{\alpha + 1}w_{0}^n.
    \end{aligned}
\end{align}
\end{subequations}
% where
% \begin{equation}\small
% \begin{gathered}\label{eq:interpolationCoeffs}
%     \alpha_\text{I} = \frac{\alpha(\alpha - 1)(\alpha - 2)}{-6}, \quad \beta_\text{I} = \frac{(\alpha - 1)(\alpha + 1)(\alpha - 2)}{2},\\
%     \gamma_\text{I} = \frac{\alpha(\alpha + 1)(\alpha - 2)}{-2}, \quad \text{and} \quad\delta_\text{I} = \frac{\alpha(\alpha + 1)(\alpha - 1)}{6}\,.
% \end{gathered}
% \end{equation}
% Treating \eqref{eq:connectionInterpol} as a system of linear equations, the virtual grid points $u_{M+1}^n$ and $w_{-1}^n$ can be solved for using
% \begin{equation}\label{eq:linSystSolution}
%     \begin{bmatrix}
%     u_{M+1}^n \\
%     w_{-1}^n
%     \end{bmatrix}
%     =
%     \mathbfcal{A}\begin{bmatrix}
%     \alpha_\text{I} w_2^n+ \beta_\text{I}w_1^n + \gamma_\text{I}w_0^n \\
%     \alpha_\text{I} u_{M-2}^n + \beta_\text{I}u_{M-1}^n + \gamma_\text{I} u_{M}^n
%     \end{bmatrix},
% \end{equation}
% where
% \begin{equation}\label{eq:Amat}
%     \mathbfcal{A} = \begin{bmatrix}
%          1 & -\delta_\text{I} \\
%          -\delta_\text{I} & 1
%     \end{bmatrix}^{-1}.\nonumber
% \end{equation}
% where
% \begin{equation}\nonumber
%     \mathbfcal{A} = \begin{bmatrix}
%          1 & -\delta_\text{I} \\
%          -\delta_\text{I} & 1
%     \end{bmatrix},
% \end{equation}
% and
% \begin{equation}\nonumber
%     \mathbf{v} = \begin{bmatrix}
%     \alpha_\text{I} w_2^n+ \beta\text{I}w_1^n + \gamma\text{I}w_0^n \\
%     \alpha_\text{I} u_{M-2}^n + \beta\text{I}u_{M-1}^n + \gamma u_{M}^n
%     \end{bmatrix}.
% \end{equation}
As will be shown in Section \ref{sec:results}, quadratic interpolation yields the expected fundamental frequency at all times. When $N$ is an integer, and thus $\alpha = 0$, recalling Eq. \eqref{eq:rigid} it can be seen that the system is reduced to \eqref{eq:resultOneConnectedPoint}. % also when interpolation needs to happen.

\subsubsection{Adding and removing Grid Points}
When $c$, and consequently $h$, is decreased and the inner boundary points surpass the virtual points (i.e. $x_{u_M} \leq x_{w_{-1}}$ and $x_{u_{M+1}} \leq x_{w_0}$) and $\lfloor N^n\rfloor > \lfloor N^{n-1}\rfloor$, a point is added to the right boundary of $\mathbf{u}$ and the left boundary of $\mathbf{w}$ (for both time indices $n$ and $n-1$) in an alternating fashion: 
\begin{equation}\label{eq:addingPoint}
        \begin{cases}\mathbf{u}^n = [\mathbf{u}^n, I_3(x_{u_{M+1}})\mathbf{v}^n]^T & \text{if $\lfloor N^n\rfloor $ is odd},\\
        \mathbf{w}^n = [I_3^\flip(x_{w_{-1}})\mathbf{v}^n, \mathbf{w}^n]^T & \text{if $\lfloor N^n\rfloor$ is even},
        \end{cases}
\end{equation}
where 
\begin{align*}
\mathbf{v}^n = [u_{M-1}^n, u_M^n, w_0^n, w_1^n],% \quad\text{and}\\
%     \mathbf{v}_\star^n &= [w_1^n, w_0^n, u_M^n, u_{M-1}^n],
\end{align*}
and
\begin{equation}\label{eq:customIp}
    I_3 = \begin{bmatrix} -\frac{\alpha'(\alpha'+1)}{(\alpha'+2)(\alpha'+3)} &\frac{2\alpha'}{\alpha'+2} &\frac{2}{\alpha'+2} 
    &-\frac{2\alpha'}{(\alpha'+3)(\alpha'+2)}
    \end{bmatrix},
\end{equation}
\SWcomment[(created using 4-point Lagrange interpolation)] with
\begin{equation}
    \alpha' = \frac{x_{w_0} - (x_{u_M} + h)}{h}\ .
\end{equation}
See Figure \ref{fig:addingPoint}.
% Note that this operation is done for both time indices $n$ and $n-1$.

\begin{figure}[h]
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{addingGridPoint4}
\caption{\label{fig:addingPoint}{The moment when a point is added to $\mathbf{u}$ at location $x_{u_M} + h$ in Eq. \eqref{eq:addingPoint}. This figure shows an extreme case where this location is far from $x_{w_0}$, i.e., $\alpha' \not\approx 0$ in Eq. \eqref{eq:customIp}.}}
\end{figure} 

Except in the case of extremely quick parameter variations, $\alpha'$ in Eq. \eqref{eq:customIp} is expected to be close to zero, i.e., $x_{u_M} + 1 \approx x_{w_0}$, meaning that $I_3 \approx [0, 0, 1, 0]$. This makes sense by looking at Figure \ref{fig:twoFreeStringsGridZoomed}, as exactly when the boundary points $u_M^n$ and $w_0^n$ surpass the virtual points $w_{-1}^n$ and $u_{M+1}^n$, these are going to be close to overlapping.

Removing grid points happens when $c$, and consequently $h$, is increased and the boundary points surpass the virtual points (i.e. $x_{u_M} \geq x_{w_0}$) and $\lfloor N^n\rfloor < \lfloor N^{n-1}\rfloor$. Compared to adding, removing grid points is slightly easier where points are simply removed from $\mathbf{u}$ and $\mathbf{w}$ (again for both $n$ and $n-1$) in an alternating fashion
\begin{equation}\label{eq:removingPoint}
\begin{cases}
    \mathbf{u}^n = [u_0^n, u_1^n ..., u_{M-1}^n]^T & \text{if $N^n$ is even}, \\
     \mathbf{w}^n = [w_1^n, w_2^n ..., w_{M_w}^n]^T & \text{if $N^n$ is odd}.
    \end{cases}
\end{equation}

A problem that arises from simply removing a grid points, is that it is possible that $u_M^n \not\approx w_0^n$ at the time of removal, which causes audible artefacts. A method of displacement correction is proposed that decreases the relative displacement of the inner boundaries the closer their grid-locations are together, not unlike a simple low-pass filter:
\begin{equation}\label{eq:dispCorr}
    \begin{aligned}
    u_M^n := u_M^n +\beta (w_0^n - u_M^n),\\
    w_0^n := w_0^n - \beta  (w_0^n - u_M^n),
    \end{aligned}
\end{equation}
with
\begin{equation*}
    \beta(\epsilon) = \frac{(1-\alpha)^\epsilon}{2}
\end{equation*}
where $\epsilon \geq 1$ is a tunable parameter and using $\alpha$ from \eqref{eq:alphaDef}. A lower $\epsilon$ decreases the chance of artifacts but will have a greater low-passing effect on the system. For low-speed changes, using $\sim 1000$ samples for removing one grid point, $\epsilon \approx 30$ ensures that $u_M^n \approx w_0^n$ and already suffices to remove artefacts arising from point removal.

Until now, only adding and removing points in the center of the system has been considered. This location could be moved anywhere along the grid, the limit being one point from the boundary. Furthermore, one does not have to add and remove points from $\mathbf{u}$ and $\mathbf{w}$ in an alternating fashion as in \eqref{eq:addingPoint}, but can just add and remove from (fx.) $\mathbf{u}$ leaving $\mathbf{w}$ the same size throughout the simulation. This results in $M = \lfloor N\rfloor - 1$ and $M_w = 1$ leaving $\mathbf{w}$ with only one moving grid point, $w_0^n$ and boundary $w_1^n = 0, \ \forall n$.


\SWcomment[The following applies to odd-ordered Lagrange interpolators $\rightarrow$] The location at where points are added and removed greatly influences the behaviour of the system, especially in the higher frequencies (see Section \ref{sec:results}). The best behaviour is obtained when the location is as close to a boundary as possible. 

\subsection{Summary \SWcomment[(just for clarity now, but maybe actually nice to include)]}
Here, Section \ref{sec:proposedMethod} is summarised and describes the final version of the proposed method.

The complete system consists of two grid functions $u_l^n$ and $w_l^n$ of size of size $M$ and $M_w$. Knowing that $\lambda=1\ \forall n$, Eq. \eqref{eq:updateEq}, written for both grid functions, becomes 
\begin{subequations}\label{eq:uwUpdates}
    \begin{align}
        u_l^{n+1} &= u_{l+1}^n + u_{l-1}^n - u_l^{n-1},\label{eq:uUpdate}\\
        w_l^{n+1} &= w_{l+1}^n + w_{l-1}^n - w_l^{n-1}\label{eq:wUpdate},
    \end{align}
\end{subequations}
%
Due to the Dirichlet boundary condition in \eqref{eq:discreteDirichlet} imposed on the outer boundaries of the system, $u_0^n$ and $w_{M_w}^n$ are $0$ at all times and are not included in the calculation. The range of calculation for Eq. \eqref{eq:uUpdate} and \eqref{eq:wUpdate} then become $l = [1, \hdots, M]$ and $l = [0, \hdots, M_w - 1]$ respectively. 

The inner boundaries are calculated using
\begin{subequations}
    \begin{align}
        u_M^{n+1} &= u_{M+1}^n + u_{M-1}^n - u_M^{n-1},\\
        w_0^{n+1} &= w_{-1}^n + w_{2}^n - w_0^{n-1}.
    \end{align}
\end{subequations}
%
where virtual grid points $u_{M+1}^n$ and $w_{-1}^n$ can be calculated using Eq. \eqref{eq:connectionInterpol}.

Then, when $\lfloor N^n \rfloor > \lfloor N^{n-1} \rfloor$ a point is added to $\mathbf{u}^n$ and $\mathbf{u}^{n-1}$ (or $\mathbf{w}^n$ and $\mathbf{w}^{n-1}$) using Eq. \eqref{eq:addingPoint}, and when $\lfloor N^n \rfloor <\lfloor N^{n-1} \rfloor$ a point is removed from the same vectors using Eq. \eqref{eq:removingPoint}. In order to prevent audible artefacts when increasing $c$ (and thus decreasing $N$), the displacement correction in \eqref{eq:dispCorr} is proposed to ensure that the inner boundaries have a similar displacement when one of them is removed.

Finally, using $\mathbfcal{U}$ from Eq. \eqref{eq:fullState} the total system can then be compactly written in matrix form as
\begin{equation}\label{eq:totalSystem}
    \mathbfcal{U}^{n+1} = 
    \mathbf{B} 
    \mathbfcal{U}^n
    - \mathbfcal{U}^{n-1}
\end{equation}
with $\lfloor N\rfloor \times \lfloor N\rfloor$ matrix
\begin{equation}\label{eq:bMat}\small
    \mathbf{B} = \begin{bmatrix}[cccc|cccc]
        & \ddots  &\ddots & & & & 0 & \\
          & 1 & 0 & 1 & & & & \\
         & & 1 & \frac{\alpha - 1}{\alpha + 1} - \beta  & 1 + \beta & -\frac{\alpha - 1}{\alpha + 1} & \\ \cline{2-7}
         & & -\frac{\alpha - 1}{\alpha + 1} & 1 + \beta & \frac{\alpha - 1}{\alpha + 1} - \beta  & 1 & & \\
            & & & &1 & 0 & 1  \\
            & 0 & &  &  &\ddots & \ddots &
       \end{bmatrix}
\end{equation}
%
% \begin{equation}\small
%     \mathbf{B} = \begin{bmatrix}[ccccccc|cc]
%     & &\ddots &\ddots & \ddots  & & \mathbf{0} & & \\
%      & & &1 & 0 & 1 & & \mathbf{0} & \\
%      & & &  & 1 & 0 & 1 & & \\
%      & &\mathbf{0} &  & \mathbfcal{A}_{1, 2}\alpha_\text{I} &\mathbfcal{A}_{1, 2}\beta_\text{I} + 1 &\mathbfcal{A}_{1, 2}\gamma_\text{I} & \mathbfcal{A}_{1, 1}(\gamma_\text{I}-\alpha_\text{I})& \\ \cline{2-8}
%      & & \mathbf{0} & &\mathbfcal{A}_{2, 2}\alpha_\text{I} &\mathbfcal{A}_{2, 2}\beta_\text{I}&\mathbfcal{A}_{2, 2}\gamma_\text{I} & \mathbfcal{A}_{2,1}(\gamma_\text{I} - \alpha_\text{I}) & 
%     \end{bmatrix}
% \end{equation}
%
Notice that when $\alpha$ approaches $1$, $\mathbf{B}$ will reduce to a matrix with ones on the diagonals next to the main diagonal and zeros elsewhere, which translates directly to the usual situation in Eq. \eqref{eq:updateEq} with $N = M + M_w + 1$. 

\section{Analysis and Results}\label{sec:results}
% \subsection{Expected behaviour}
This section shows the analysis of the system presented in the previous section and its behaviour.

% \subsection{Static}
\subsection{Frequency}
In order to determine whether the proposed method yields an output with the correct frequency content, a spectrum is taken of the system's output. The system with $N=15.5$ (so $\alpha = 0.5$ in \eqref{eq:bMat}) at a sample rate of $f_\text{s} = 44100$ Hz is compared to the same system with $f_\text{s} = 88200$ Hz resulting in $N=31$ ($\alpha = 0$) for the same $f_0$ according to Eq. \eqref{eq:fundamentalFreq}. See Figure \ref{fig:spectra}.

\begin{figure}[ht]
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{spectraDoubleSampleRateQuadratic.eps}
\caption{\label{fig:spectra}{A system with $N = 15.5$ at $f_\text{s} = 44100$} compared to a system with $N = 31$ at $f_\text{s} = 88200$. Both are supposed to have the same fundamental frequency $f_0$ according to Eq. \eqref{eq:fundamentalFreq}.}
\end{figure} 

The output of the system at integer $N = 31$ contains partials at perfect integer multiples of $f_0$ (Eq. \eqref{eq:fundamentalFreq}). When this is compared to the output of the system with $N = 15.5$, one can observe that the lower partials are nearly perfectly overlapping, whereas higher partials exhibit slight downwards deviations, exponentially increasing with frequency.

% \subsection{Dynamic}
For a more detailed look at the behaviour of the system, a modal analysis can be performed on system \eqref{eq:totalSystem}. The modal frequency of the $p$'th mode can be retrieved as
\begin{equation}\label{eq:modalAnalysis}
    f_p = \frac{1}{2\pi k}\cos^{-1}\left(\frac{1}{2}\text{eig}_p(\mathbf{B})\right).
\end{equation}

As a test case, the wave speed is dynamically varied from $c = 2940$ ($N = 15$) to $c = 2205$ ($N = 20$), changing $\mathbf{B}$ and thus the modal frequencies over time. The displacement correction presented in Eq. \eqref{eq:dispCorr} is not included in this analysis ($\epsilon \gg 1$), but will be elaborated on in Section \ref{sec:dispCorrRes}. The results of the analysis are shown in Figure \ref{fig:modalAnalysis}. Figure \ref{fig:spectrogram} shows the resulting spectrogram of the system excited at $n=0$ with a narrow raised cosine and the output retrieved at $u_1$.

\begin{figure}[ht]
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{modalAnalysisQuadratic.eps}
\caption{\label{fig:modalAnalysis}{Modal analysis of system \eqref{eq:totalSystem} using \eqref{eq:modalAnalysis}. The wave speed is reduced from $c = 2940$ ($N = 15$) to $c = 2205$ ($N = 20$).}}
\end{figure} 
\begin{figure}[ht]
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{specQuadratic.eps}
\caption{\label{fig:spectrogram}{System output. The sound output follows the same pattern as predicted by the analysis shown in Figure \ref{fig:modalAnalysis}.}}
\end{figure} 

In the following 
\begin{equation}
    \varepsilon_p = \frac{f_p - pf_0}{f_0}\quad \text{[\%]}
\end{equation}
is used to calculate the harmonic deviation of mode $p$ from an integer multiple of the fundamental. Furthermore, the lowest mode generated by the analysis is referred to as $f_1$ and should ideally be equal to $f_0$ calculated using Eq. \eqref{eq:fundamentalFreqCont}.

The first thing one can observe from Figure \ref{fig:modalAnalysis} is that the frequencies of the modes decrease as $c$ decreases. The lower the mode, the more linear this decrease happens. Between $N = 15$ and $N = 16$, $f_1$ maximally deviates by $-0.12$ Hz or $\varepsilon_1 = -0.008\%$. In this same interval $f_{15}$ maximally deviates by $-827.15$ Hz or $\varepsilon_{15} = -57\%$. This deviation for mode number $p$ gets progressively less as $N$ increases. The maximum deviation for the highest mode number $f_{\lfloor N\rfloor}$, however, gets larger with a larger $N$, with $\text{max}(\varepsilon_{\lfloor N \rfloor})$ approaching $-100\%$ for extremely large values of $N$ ($>1000$). These deviations only happen between integer values of $N$ where at integer $N$ all modes are perfect integer multiples of $f_0$ and $\varepsilon_p = 0 \%$ for all $p$.

Experiments with higher even-ordered Lagrange interpolators shows that $\varepsilon_p$ becomes smaller, but not by a substantial amount. The quadratic interpolator has thus been chosen for being simpler and more flexible while not being substantially worse than higher order interpolators.

Another observation from Figure \ref{fig:modalAnalysis} is that there are always $\lfloor N \rfloor$ modes present, corresponding to the number of moving points of the system. As can be seen from the spectrum in Figure \ref{fig:spectrogram} the highest mode is not excited. When an implementation of the system using this method, with wave speed $c = 2940$ m/s (static) is compared to a normal implementation of the 1D wave equation (shown in Section \ref{sec:FDTD}) with the same wavespeed, identical outputs are observed, even though the latter has $N-1$ moving points. This proves that at integer $N$ the method reduces to the normal case. If the system is excited when $N$ is not an integer, the highest mode will also be excited.

Using the quadratic interpolation from \eqref{eq:connectionInterpol}, or any other even-ordered Lagrange interpolator for that matter, the modal behaviour of the system does not change based on location. Experiments done with odd-ordered Lagrange interpolators showed that better behaviour is observed when points are added / removed closer to the boundaries. 

\subsection{Displacement correction}\label{sec:dispCorrRes}
(FIR) Comb filtering effect where resonances appear depending on the location of correction. Middle has least

\subsection{Limit on speed of change}
The method presented in this paper can only add or remove a maximum one point per sample using Eqs. \eqref{eq:addingPoint} and \eqref{eq:removingPoint}. The speed of decreasing $f_0$ according to \eqref{eq:fundamentalFreq} is thus limited by the following condition
\begin{equation}\label{eq:pointCondition}
    |N^n - N^{n-1}| \leq 1. 
\end{equation}
Though this is the maximal limitation on speed, a much lower limitation needs to be placed 
% Notes:
% In the case that $\alpha = 0$ in Eq. \eqref{eq:totalSystem} (and thus $x_{u_M} = x_{w_0}$), one could go up to adding two points at a time by adding $u_{M+1}^n$ according to Eq. \eqref{eq:addingPoint} and adding an extra point $u_{M+2}^n$ using \eqref{eq:calcVirtualGridPoints} (in this case $u_{M+2}^n = w_0^n$). This would, however, not work if $\alpha \neq 0$, as a point added to $\mathbf{u}^n$ with $x_\text{i} < w_0$ needs interpolator \eqref{eq:customIp} and $\alpha'$ would be greater than $1$. As Eq. \eqref{eq:customIp} only works if $0\leq \alpha' \leq 1$, it is best to abide condition \eqref{eq:pointCondition} to be safe. 

% No speed limit if
% \begin{equation}
%     \text{floor}(N^n) = \text{floor}(N^{n-1})\Rightarrow M^n = M^{n-1},
% \end{equation}
% i.e., if no points are added or removed from the system. 

\section{Discussion}
To decide whether the proposed method works satisfactory, the results presented in the previous section are compared to the method requirements listed in Section \eqref{sec:methodReq}. 

The fact that he highest mode is not excited is probably due to the restriction imposed on the two moving but connected points through the rigid connection.


All issues with the proposed method happen in higher frequencies. Physical processes usually lose the highest frequencies first

Due to high-frequency losses in physical systems. 

Higher modes

\SWcomment[Discussion:] As can be seen from the figure, the lower harmonic partials of both systems line up almost exactly before the partials interpolated start to deviate towards the lower end of the spectrum.

($<0.2\%$ of their respetcive frequency, $<1.3\%$ of the fundamental $f_0$). 


Applications could be non-linear systems where parameters are modulated based on the state of the system. 

The proposed method does not provide the exact solution to the problem, but does circumvent the need for upsampling and higher orders of computations necessary to approximate this solution. Even though interpolation needs to happen, the drawbacks of full-grid interpolation can be avoided by not `listening' to the location where points are added but rather closer to the boundary. If one wants to listen to the center, the location where points are added or removed can easily be changed.


frequency domain, the locations of the partials comparing the discrete 1D wave with $N = 30.5$ and $f_\text{s} = 44100$ (interpolation needs to happen) with $N = 61$ and $f$ 

If the amount that a parameter changes within a small enough period of time (give values here, hopefully referring back to the results) the fact that points are added at a specific location (rather than distributed over the grid) will not matter as... 



\SWcomment[Notes (warning, very pretentious, and probably untrue..):] The aforementioned drawbacks of the method are eclipsed by the advantages it brings in terms of dynamic parameter changes and quality improvements. 

The 


\section{Conclusion and Future Work}

Future work includes creating an adaptive version of the displacement correction that changes its effect depending on the speed at which the grid is changed.  
Though this method has only been presented using the 1D wave equation it could potentially be applied to any kind of 1D FDS 



\appendix
\section{Iterations}\label{app:A}
In this appendix, some iterations done over the course of this project will be shown in more detail. In the following, the 1D wave equation with a wave speed of $c = 1470$ m/s, a length of $L = 1$ m, Dirichlet boundary conditions and a sample rate of $f_\text{s} = 44100$ Hz is considered, and -- through Eq. \eqref{eq:compactLambda} -- satisfies the CFL condition with equality. These values result in $N = 30$, or a grid of 31 points including the boundaries. Then, the wave speed is decreased to $c \approx 1422.6$ m/s, i.e., the wave speed that results in $N=31$ and satisfies the stability condition with equality again. 

\subsection{Full-Grid Interpolation}
One way to go from one grid to another is performing a full-grid interpolation \cite[Chap. 5]{bilbao2009}. If the number of points changes according to Eq. \eqref{eq:orderOfCalcGrid}, i.e., if $N^n \neq N^{n-1}$ the full state of the system ($u_l^n, u_l^{n-1}\ \forall l$)  can be interpolated to the new state. See Figure \ref{fig:fullGrid}. 

\begin{figure}[ht]
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{fullGrid}
\caption{\label{fig:fullGrid}{Upsampling $u$ (with an arbitrary state) using (linear) full-grid interpolation with $N^{n-1} = 30$ and $N^n = 31$. The horizontal axis is normalised with respect to $N^n$.}}
\end{figure} 

An issue that arises using this method is that the Courant number $\lambda$ will slightly deviate from the CFL condition as $c$ changes. Using Eq. \eqref{eq:compactLambda} with $L/ck$ approaching $31$ (from below), the minimum value of $\lambda \approx 30/31 \approx 0.9677$.
%\footnote{Eq. \eqref{eq:orderOfCalcGrid} can be compactly rewritten as $\lambda = \frac{ck}{L}\cdot \text{floor}\left(\frac{L}{ck}\right)$. As $L/ck$ approaches $31$ (from below), $\lambda \approx \frac{30}{31}$.}
This, employing Eq. \eqref{eq:fmax}, has a maximum frequency output of $f_\text{max} \approx 18,475$ Hz. 
%For slightly lower values of $c$, $N = 31$ and $\lambda \approx 1$. 
The Courant number will deviate more for higher values of $c$ and thus lower values for $N$ -- for instance, if $N$ approaches $11$ (from below), $\lambda \approx 10/11 \approx 0.9091$ and $f_\text{max} \approx 16,018$ Hz.

Another problem with full-grid interpolation, is that it has a low-passing effect on the system state, and thus on the output sound. %Figure \ref{fig:fullGrid} shows the biggest changes are in the state are at the locations with the biggest difference between the states of consecutive grid points.
Furthermore, this state-interpolation causes artefacts or `clicks' in the output sound as the method causes sudden variations in the states.  

All the aforementioned issues could be solved by using a (much) higher sample rate and thus more grid points, but this would render this method impossible to work in real time.

\subsection{Adding and removing Points at the Boundary}\label{sec:addAtBoundary}
To solve the issues exhibited by a full-grid interpolation, points can be added and removed at a single location and leave most points unaffected by the parameter changes. A good candidate for a location to do this is at a fixed (Dirichlet) boundary. The state $u$ at this location is always $0$ so points can be added smoothly. 

As $c$ decreases, $h$ can be calculated according to Eq. \eqref{eq:orderOfCalcGrid} and decreases as well.

This has a physical analogy with tuning a guitar string. Material enters and exits the neck (playable part of the string) at the nut, which in discrete time means grid points appearing and disappearing at one boundary.

To yield smooth changes between grid configurations, an interpolated boundary has been developed, the possibility of which has been briefly mentioned in \cite[p. 145]{bilbao2009}. The Dirichlet condition in Eq. \eqref{eq:contDirichlet} can be extended to be the simply supported boundary condition:
\begin{equation}
    u(x, t) = \frac{\partial^2}{\partial x^2}u(x, t) = 0 \quad \text{where} \quad x = 0, L,
\end{equation}
or, when discretised,
\begin{equation}\label{eq:simplySupportedDiscrete}
    u_l^n = \delta_{xx}u_l^n = 0, \quad \text{where} \quad l = 0, N.
\end{equation}
This means that on top of that the state of the boundary should be $0$, the curvature around it should also be $0$. One can again solve for the virtual grid points at the boundary locations, yielding
\begin{equation}
    u_{-1}^n = -u_1^n \quad \text{and} \quad u_{N+1}^n = -u_{N-1}^n.
\end{equation}
This is visualised in Figure \ref{fig:simplySupportedBound}.

\begin{figure}
\includegraphics[width=\reprintcolumnwidth]{simplySupportedBoundary}
\caption{\label{fig:simplySupportedBound}{The simply supported boundary condition: both the state and the curvature at the boundary -- at $l=0$ -- should be $0$.}}
\end{figure} 

If the flooring operation in Eq. \eqref{eq:numberOfIntervals} is removed this introduces a fractional number of grid points.


The by-product of using a fractional $N$ this is that the CFL condition in \eqref{eq:CFL} can now always be satisfied with equality no matter what the wave speed is.

An issue with this method is that removing points is much harder than adding.

their interactions change through a change in the grid spacing and wave speed. This interaction, though, is defined by $\lambda$ which 

\begin{figure}
%% \reprintcolumnwidth is the same in preprint and reprint for
%% ease of use for authors:
\includegraphics[width=\reprintcolumnwidth]{boundaryGrid}
\caption{\label{fig:changingBoundary}{The grid changing over time}}
\end{figure} 

% \subsubsection{\SWcomment[If the above iterations need to be summarised:]}
\bibliography{myBib}
\end{document}




